/**
 *
 * Replay IOCTL 0x{0:x} script to {1:s} (in {2:s})
 * Auto-generated by CFB
 *
 */

 // Change to 0 to make it a standalone executable
 #define BUILD_AS_DLL 0

 // Change to 0 to not show the error messages
 #define DEBUG 1

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdint.h>

#include <string>
#include <iostream>
#include <vector>

#define DEVICE_NAME   L"{1:s}"
#define DRIVER_NAME   L"{2:s}"
#define IOCTL_CODE    0x{0:x}

using namespace std;


HMODULE g_hLoadLibrary = NULL;

typedef HANDLE (WINAPI *CreateFileSig)(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
typedef BOOL (WINAPI *CloseHandleSig)(HANDLE);
typedef BOOL (WINAPI* DeviceIoControlSig)(HANDLE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
typedef DWORD (WINAPI* GetLastErrorSig)();


BOOL HexStrToHexVector(const std::string& in, std::vector<uint8_t>& out)
{{
    for(size_t i=0; i<in.size(); i+=2)
    {{
        uint8_t b = (((in[i]-'0')<<4)&0x0f) | ((in[i+1]-'0')&0x0f);
        out.push_back(b);
    }}
    return TRUE;
}}


#if BUILD_AS_DLL == 1
extern "C" __declspec(dllexport) DWORD InjectPayload()
#else
int main(int argc, char** argv)
#endif
{{
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    BOOL bResult = FALSE;
    DWORD lpBytesReturned = 0;

    if(!g_hLoadLibrary)
        g_hLoadLibrary = GetModuleHandle(TEXT("kernel32.dll"));

    CreateFileSig pfnCreateFile = (CreateFileSig)GetProcAddress(g_hLoadLibrary, TEXT("CreateFileW"));
    CloseHandleSig pfnCloseHandle = (CloseHandleSig)GetProcAddress( g_hLoadLibrary, TEXT("CloseHandle"));
    DeviceIoControlSig pfnDeviceIoControl = (DeviceIoControlSig)GetProcAddress( g_hLoadLibrary, TEXT("DeviceIoControl"));
    GetLastErrorSig pfnGetLastError = (GetLastErrorSig)GetProcAddress( g_hLoadLibrary, TEXT("GetLastError"));

    std::vector<uint8_t> IrpDataIn;
    HexStrToHexVector( std::string({3:s}), IrpDataIn );
    std::vector<uint8_t> IrpDataOut;
    IrpDataOut.resize({4:d});


    do
    {{
#ifdef DEBUG
        wprintf(L"Getting handle for device '%s' with code %#x\n", DEVICE_NAME, IOCTL_CODE);
#endif
        hDevice = pfnCreateFile(
            DEVICE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );

        if (hDevice == INVALID_HANDLE_VALUE)
        {{
#ifdef DEBUG
            wprintf(L"CreateFile() failed");
#endif
            break;
        }}

#ifdef DEBUG
        wprintf(L"Got device %p, sending payload\n", hDevice);
#endif
        bResult = pfnDeviceIoControl(
            hDevice,
            IOCTL_CODE,
            IrpDataIn.data(),
            IrpDataIn.size(),
            IrpDataOut.data(),
            IrpDataOut.size(),
            &lpBytesReturned,
            (LPOVERLAPPED) NULL
        );

        if (bResult==FALSE)
        {{
#ifdef DEBUG
            wprintf(L"DeviceIoControl failed");
#endif
            break;
        }}
    }}
    while(0);

    if(hDevice != INVALID_HANDLE_VALUE)
    {{
#ifdef DEBUG
        wprintf(L"Closing device %p\n", hDevice);
#endif
        pfnCloseHandle(hDevice);
    }}

    return pfnGetLastError();
}}


#if BUILD_AS_DLL == 1
extern "C" BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{{
    switch (ul_reason_for_call)
    {{
    case DLL_PROCESS_ATTACH:
        InjectPayload();
        return FALSE;

    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        break;
    }}

    return TRUE;
}}

extern "C" __declspec(dllexport) DWORD TestInjection()
{{
#ifdef DEBUG
    wprintf(L"TestInjection() works\n");
#endif
    return ERROR_SUCCESS;
}}
#endif