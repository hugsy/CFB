#
#
# PowerShell replay script for IOCTL 0x{0:x} to {1:s} (in {2:s})
#
# Auto-generated by CFB
#
#


Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;	
using System.Runtime.InteropServices;	
using System.Security.Principal;

public static class CFB
{{
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr CreateFile(
        String lpFileName,
        UInt32 dwDesiredAccess,
        UInt32 dwShareMode,
        IntPtr lpSecurityAttributes,
        UInt32 dwCreationDisposition,
        UInt32 dwFlagsAndAttributes,
        IntPtr hTemplateFile
    );
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool DeviceIoControl(
        IntPtr hDevice,
        int IoControlCode,
        byte[] InBuffer,
        int nInBufferSize,
        byte[] OutBuffer,
        int nOutBufferSize,
        ref int pBytesReturned,
        IntPtr Overlapped
    );
    [DllImport("kernel32.dll", SetLastError = true, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto)]
    public static extern bool CloseHandle(IntPtr hObject);
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern void OutputDebugString(string lpOutputString);
    [DllImport("kernel32.dll")]
    public static extern uint GetLastError();
}}
"@;

function Convert-HexToByteArray
{{
    param([parameter(Mandatory=$true)][String]$HexString)
    $Bytes = [byte[]]::new($HexString.Length / 2)
    for($i=0; $i -lt $HexString.Length; $i+=2)
    {{
        $Bytes[$i/2] = [convert]::ToByte($HexString.Substring($i, 2), 16)
    }}
    $Bytes
}}

function Debug-Info
{{
    param([string]$Message )
    [CFB]::OutputDebugString("[*] " + $Message + "`n")
    Write-Host("[*] " + $Message)
}}

function Debug-Success
{{
    param([string]$Message )
    [CFB]::OutputDebugString("[+] " + $Message + "`n")
    Write-Host("[+] " + $Message)
}}

function Debug-Error
{{
    param([string]$Message )
    [CFB]::OutputDebugString("[-] " + $Message + "`n")
    Write-Error("[-] " + $Message)
}}


$IoctlCode    = 0x{0:x}
$DeviceName   = "{1:s}"
$DriverName   = "{2:s}"
$IrpDataIn    = Convert-HexToByteArray({3:s})
$IrpDataOut   = [byte[]]::new({4:d})

Debug-Info("Getting handle to device {{0:s}}..." -f $DeviceName)

Set-Variable OPEN_EXISTING -Option Constant -Value 3
Set-Variable FILE_ATTRIBUTE_NORMAL -Option Constant -Value 0x80

$hDevice = [CFB]::CreateFile(
    $DeviceName,
    [System.IO.FileAccess]::ReadWrite,
    [System.IO.FileShare]::ReadWrite,
    [System.IntPtr]::Zero,
    $OPEN_EXISTING,
    $FILE_ATTRIBUTE_NORMAL,
    [System.IntPtr]::Zero
)

if ($hDevice -eq -1)
{{
    Debug-Error("Unable to get a handle to device {{0:s}}..." -f $DeviceName)
    Return
}}

$dwReturnLength = 0

Debug-Info("Sending request (IoctlCode=#{{0:x}}) via handle {{1:d}}..." -f $IoctlCode,$hDevice)
$res = [CFB]::DeviceIoControl(
    $hDevice,
    $IoctlCode,
    $IrpDataIn,
    $IrpDataIn.Length,
    $IrpDataOut,
    $IrpDataOut.Length,
    [ref]$dwReturnLength,
    [System.IntPtr]::Zero
)

if ( $res -eq $true )
{{
    Debug-Success("Success")
    if($dwReturnLength -gt 0)
    {{
        $IrpDataOut | Format-Hex
    }}
}}
else
{{
    Debug-Error("Failed, GetLastError=#{{0:x}}" -f [CFB]::GetLastError())
}}

Debug-Info("Closing handle {{0:d}}..." -f $hDevice)
[CFB]::CloseHandle($hDevice)
